=================================================================================
INTRODUCTION                              *nixCats.flake.nixperts.nvimBuilder*

Wait, why is this code? 
I could not find a better way to incorporate code examples without
just doing this and including more comments than code.

--------------------------------------------------------------------------
                                *nixCats.flake.nixperts.nvimBuilder.arguments*
# this function takes a set with the following items:
{ 
  # our arguments ? and their default values
  self
  , pkgs
  , categories ? {}
  , settings ? {}

  , startupPlugins ? {}
  , optionalPlugins ? {}
  , lspsAndRuntimeDeps ? {}
  , propagatedBuildInputs ? {}
  , environmentVariables ? {}
  , extraWrapperArgs ? {}
  # these ones take sets of lists of FUNCTIONS,
  # and those functions return lists of packages.
  # Idk why they work that way, 
  # but I combine the outputs.
  # the source says:
    /* the function you would have passed to python.withPackages */
  , extraPythonPackages ? {}
  , extraPython3Packages ? {}
  # same thing except for lua.withPackages
  , extraLuaPackages ? {}
  }:
  let
    # when packaging, one of these is passed, but it may not have everything.
    # update the config with whatever new options were passed
    config = {
      wrapRc = true;
      RCName = "";
      viAlias = false;
      vimAlias = false;
      withNodeJs = false;
      withRuby = true;
      extraName = "";
      withPython3 = true;
    } // settings;

--------------------------------------------------------------------------
                                   *nixCats.flake.nixperts.nvimBuilder.opener*

    # package the entire flake as plugin
    LuaConfig = pkgs.stdenv.mkDerivation {
        name = config.RCName;
        builder = builtins.toFile "builder.sh" ''
          source $stdenv/setup
          mkdir -p $out
          cp -r ${self}/* $out
        '';
      };

    # see :help nixCats
    nixCats = pkgs.stdenv.mkDerivation {
      name = "nixCats";
      builder = let
        cats = builtins.toFile "nixCats.lua" ''
            vim.api.nvim_create_user_command('NixCats', 
            [[lua print(vim.inspect(require('nixCats')))]] , 
            { desc = 'So Cute!' })
            return ${(import ./utils.nix).luaTablePrinter categories}
          '';
      in builtins.toFile "builder.sh" ''
        source $stdenv/setup
        mkdir -p $out/lua
        mkdir -p $out/doc
        cp ${cats} $out/lua/nixCats.lua
        cp -r ${self}/nixCatsHelp/* $out/doc
      '';
    };

    wrapRc = if config.RCName != "" then config.wrapRc else false;

    # and create our customRC to call it
    customRC = if wrapRc then "lua require('" + config.RCName + "')" else "";

    extraPlugins = if wrapRc then [ nixCats LuaConfig ] else [ nixCats ];

---------------------------------------------------------------------------------
                             *nixCats.flake.nixperts.nvimBuilder.basicFlatmap*

    # this is what allows for dynamic packaging in flake.nix
    # It includes categories marked as true, then flattens to a single list

    filterAndFlatten = (import ./utils.nix)
          .filterAndFlattenAttrsOfLists pkgs categories;

    # we can use that function to filter many of the options.
    # anything that has an argument in the wrapper and 
    # is a list of categories of packages, you can filter this way

    buildInputs = [ pkgs.stdenv.cc.cc.lib ] ++ filterAndFlatten propagatedBuildInputs;
    start = extraPlugins ++ filterAndFlatten startupPlugins;
    opt = filterAndFlatten optionalPlugins;

    # I didnt add stdenv.cc.cc.lib, so I would suggest not removing it.
    # It has cmake in it I think among other things?

---------------------------------------------------------------------------------
                           *nixCats.flake.nixperts.nvimBuilder.mapWrapArgCats*

    # This one filters and flattens like above but for attrs of attrs 
    # and then maps name and value
    # into a list based on the function we provide it.
    # its like a flatmap function but with a built in filter for category.
    # you may use this to create entirely new 
    # categories in the builder for wrapper arguments
    # more info on wrapper arguments below.

    filterAndFlattenWrapAttrs = (import ./utils.nix)
          .FilterAttrsOfAttrsFlatMapInner pkgs categories;

    # This one filters and flattens attrs of lists and then maps value
    # into a list based on the function we provide it.
    # it the same as above but for a mapping function with 1 argument
    # because the inner thing we are mapping is a list not a set.

    filterAndFlattenWrapLists = (import ./utils.nix)
          .FilterAttrsOfListsFlatMapInner pkgs categories;

    # Each of these 2 functions actually take 4 arguments. But actually,
    # they are 4 separate functions inside one another.
    # therefore we can supply it with the first 2 arguments, then supply it
    # with a function to map, then later supply it with the final argument.
    # currently, it now works very much like a regular flatmap function.
    # it now takes a function, and a set of categories of stuff.


---------------------------------------------------------------------------------
                          *nixCats.flake.nixperts.nvimBuilder.usingWrapArgMap*

    # we are going to provide a function to map name and value
    # into a wrapper argument that sets an environment variable

    FandF_envVarSet = filterAndFlattenWrapAttrs 
          (name: value: ''--set ${name} "${value}"'');

    # and this one we define a function that just passes an arg through.
    # this one takes an a set of lists rather than a set of sets

    FandF_passWrapperArgs = filterAndFlattenWrapLists (value: value);


    # you can use filterAndFlattenWrapLists and its attr set counterpart in order
    # to create new sets of categories in the flake's builder function
    # that are to do with wrapper args.

    # you would add the set as an argument to this file, then, create one of these.
    # to create one, pass it a new wrapping function. I.E. 
    # FandFpassFlags = filterAndFlattenWrapLists (value: "--add-flags ${value}")

    # and this is how we add our lsps/runtime dependencies/whatever we need available at runtime

    FandF_WrapRuntimeDeps = filterAndFlattenWrapLists (value:
      ''--prefix PATH : "${pkgs.lib.makeBinPath [ value ] }"''
    );

    # this next part takes those wrapper args and 
    # concatenates them together with a space
    # we will send this to the official wrapNeovim stable
    extraMakeWrapperArgs = builtins.concatStringsSep " " (
      # We call the functions above and add them into a big list
      (FandF_WrapRuntimeDeps lspsAndRuntimeDeps)
      ++ (FandF_envVarSet environmentVariables)
      ++ (FandF_passWrapperArgs extraWrapperArgs)

      # More info at:
      # https://github.com/NixOS/nixpkgs/blob/master/pkgs/build-support/setup-hooks/make-wrapper.sh

    );

---------------------------------------------------------------------------------
                            *nixCats.flake.nixperts.nvimBuilder.extraPackages*

    # extraPythonPackages and the like require FUNCTIONS that return lists.
    # so we make a function that returns a function that returns lists.
    # this is used for the fields in the wrapper where the default value is (_: [])
    # This just makes a function that calls all the functions we want, 
    # then combines the results into 1 list.

    combineCatsOfFuncs = sect:
      (x: let
        appliedfunctions = builtins.map (value: (value) x ) (filterAndFlatten sect);
        combinedFuncRes = builtins.concatLists appliedfunctions;
        uniquifiedList = pkgs.lib.unique combinedFuncRes;
      in
      uniquifiedList);

---------------------------------------------------------------------------------
                         *nixCats.flake.nixperts.nvimBuilder.generatingNeovim*

    # here is where we add our propagated build dependencies
    myNeovimUnwrapped = pkgs.neovim-unwrapped.overrideAttrs (prev: {
      propagatedBuildInputs = buildInputs;
    });
  in
  # add all our stuff, and wrap it all up!
  # the following is just the regular pkgs.wrapNeovim
  # except it also accepts wrapRc as an argument
(import ./wrapNeovim.nix).wrapNeovim pkgs myNeovimUnwrapped {
  inherit wrapRc;
  inherit extraMakeWrapperArgs;
  viAlias = config.viAlias;
  vimAlias = config.vimAlias;
  configure = {
    inherit customRC;
    packages.myVimPackage = {
      inherit start;
      inherit opt;
    };
  };

  # I dont know what these do, but I implemented them for completeness?
  # the extra packages arguments take (_: []) as a default argument

  # I dont know what these do, but I implemented them?
    /* the function you would have passed to python.withPackages */
  extraPythonPackages = combineCatsOfFuncs extraPythonPackages;
    /* the function you would have passed to python.withPackages */
  withPython3 = config.withPython3;
  extraPython3Packages = combineCatsOfFuncs extraPython3Packages;
    /* the function you would have passed to lua.withPackages */
  extraLuaPackages = combineCatsOfFuncs extraLuaPackages;
  withNodeJs = config.withNodeJs;
  withRuby = config.withRuby;
  extraName = config.extraName;
}

===========================================================================================================
vim:tw=78:ts=8:ft=help:norl:
